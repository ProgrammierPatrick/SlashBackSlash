# LANG SBS
# MAIN LIBRARY

# ================
# Common functions
# ================
/id (\x x)
/Y (\f (\x f (x x)) (\x f (x x)))
# wildcard
/_ id

# =====
# Logic
# =====

/true  (\t \f t)
/false (\t \f f)

/and (\a \b a b a)
/or  (\a \b a a b)
/not (\a a false true)
/xor (\a \b a (not b) b)

# ======
# Tuples
# ======
/tup (\a \b \f f a b)
/first (\t t true)
/second (\t t false)

# make tuple of 1, 2:
# /t (tup 1 2)
# get first element
# /f (first t)
# get second element
# /s (second t)

# =======
# Numbers
# =======
/0 (\f \x x)
/inc (\n \f \x f (n f x))
# allias n + m
/+ inc

/add (\a \b a inc b)
/mul (\a \b \f a (b f))
/is0 (\n n (\x false) true)
/dec (\n second
    (
        n
        (\p tup (inc (p first)) (p first))
        (tup 0 0)
    )
)
/sub (\a \b b dec a)

# =====
# Lists
# =====

# empty list
/[] (\f \x x)

# append element a at front to list b
/cons (\h \t \f \x f h (t f x))
# allias l1 . l2
/. cons

# get head and tail from list
/head (\l l true _)
/tail (\l second
    (
        l
        (\h \p tup (cons h (first p)) (first p))
        (tup [] [])
    )
)
/is[] (\l l (\h \t false) true)

/[ (\x \f f x)
/, (\y \x \f . y (f x))
/] (\y . y  [])

# len ([ a , b ]) => 2
/len (\l l (\h \t + t) 0)

# map f ([ a , b ]) => [ (f a) , (f b) ]
/map (\f \l l (\h \t . (f h) t) [])

# apply f ([ a , b ]) => f a b
/apply (Y (\r \f \l Y r (f (head l)) (tail l)))

# filter (\n not (is0 n)) ([ 0 , 1 , 2 ]) => [ 1 , 2 ]
/filter (\f \l l (\h \t f h (. h t) t) [])

# get 1 ([ 3 , 5 , 2 ]) => 5
/get (Y (\r \n \l is0 n (head l) (r (dec n) (tail l)))
